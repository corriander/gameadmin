CREATE DATABASE gameadmin;

\c gameadmin;

CREATE SCHEMA fraps;

CREATE TABLE fraps.dataset (
    id serial PRIMARY KEY NOT NULL,
    filepath text UNIQUE NOT NULL
);
-- ALTER TABLE fraps.dataset ADD CONSTRAINT dataset_filepath_key UNIQUE (filepath);

DROP TABLE IF EXISTS fraps.frames;
CREATE TABLE fraps.frames (
    dataset_id bigint REFERENCES fraps.dataset (id),
    frame int NOT NULL,
    t_delta float NOT NULL,
    UNIQUE (dataset_id, frame)
);

COMMENT ON TABLE fraps.frames IS 'Each frame recorded by Fraps and the time delta (ms)';

CREATE OR REPLACE FUNCTION fraps.import_frames (p_path varchar(260))
RETURNS void
AS
$DEF$

BEGIN

    DROP TABLE IF EXISTS pg_temp._import_frames;
    CREATE TEMPORARY TABLE pg_temp._import_frames (frame int, t_delta float);

    EXECUTE format(
                $$
                COPY pg_temp._import_frames
                FROM '%s' DELIMITER ',' CSV HEADER;
                $$,
                p_path
            );

       WITH dataset_insert AS (
                INSERT INTO fraps.dataset (filepath)
                VALUES (p_path)
                ON CONFLICT DO NOTHING
                RETURNING id
            )
     INSERT INTO fraps.frames
     SELECT dsi.id
          , frame
          , t_delta
       FROM dataset_insert dsi
          , pg_temp._import_frames
      WHERE dsi.id IS NOT NULL
      ORDER BY dsi.id
          , frame
         ON CONFLICT DO NOTHING
     ;

END
$DEF$
LANGUAGE plpgsql
;

COMMENT ON FUNCTION fraps.import_frames(varchar(260)) IS 'Import *frametimes.csv generated by Fraps.';

-- Example usage:
-- SELECT fraps.import_frametimes('L:\data\fraps\fps\WolfNewOrder_x64 2017-03-19 10-07-16-62 frametimes.csv');

-- Remove data:
-- TRUNCATE fraps.frametimes;
-- DELETE FROM fraps.dataset;

DROP VIEW IF EXISTS fraps.dataset_view;
CREATE VIEW fraps.dataset_view AS
SELECT id
     , filepath
     , regexp_replace(filepath, '.*[\\/]([^ ]+).*$', '\1') AS exe
     , to_timestamp(
	       regexp_replace(
			   filepath,
			   '.*(\d\d\d\d-\d\d-\d\d \d\d-\d\d-\d\d-\d\d).*',
			   '\1'
	       ),
		   'YYYY-MM-DD HH24-MI-SS-MS'
	   ) AS t0
  FROM fraps.dataset
;


DROP FUNCTION IF EXISTS fraps.fps(bigint);
 CREATE OR REPLACE FUNCTION fraps.fps (p_id bigint)
RETURNS TABLE (
    second bigint,
    fps bigint
)
AS
$DEF$
BEGIN

RETURN QUERY
  WITH dataset AS (
           SELECT *
             FROM fraps.dataset_view dsv
            WHERE dsv.id  = p_id
       )
     , frames AS (
           SELECT *
             FROM fraps.frames f
             JOIN dataset ds
               ON f.dataset_id = ds.id
       )
     , frames_meta AS (
           SELECT min(t0) AS t0
                , max(t_delta) AS t1
             FROM frames
       )
     , bins AS (
             WITH _bins AS (
                       SELECT row_number() OVER () AS id
                            , t.t
                         FROM generate_series(
                                  (SELECT t0 FROM frames_meta),
                                  (SELECT t0 FROM frames_meta) + (floor((SELECT t1 FROM frames_meta) / 1000) ||' seconds')::interval,
                                  INTERVAL '1000 milliseconds'
                              ) AS t(t)
                  )
           SELECT l.id
                , l.t AS "t_i"
                , r.t AS "t_(i+1)"
             FROM _bins l
             LEFT JOIN _bins r
               ON l.id = r.id - 1
            WHERE l.id < (SELECT max(id) FROM _bins)
       )
     , binned_frames AS (
            SELECT fr.frame
                 , bins.id AS bin
              FROM (SELECT *
                         , (SELECT t0 FROM frames_meta) + (t_delta || ' milliseconds')::interval AS t
                      FROM frames) fr
              JOIN bins
                ON fr.t >= bins."t_i"
               AND fr.t < bins."t_(i+1)"
       )
SELECT bin
     , count(*)
  FROM binned_frames
 GROUP BY bin
 ORDER BY bin
;

END
$DEF$
LANGUAGE plpgsql
;

-- GPU-Z data.
CREATE SCHEMA gpuz;

DROP TABLE IF EXISTS gpuz.sensor;
CREATE TABLE gpuz.sensor (
    t timestamp PRIMARY KEY NOT NULL,
    f_core float,
    f_mem float,
    temp float,
    speed_fan_pc smallint,
    speed_fan_rpm int,
    load smallint,
    mem_controller_load smallint,
    mem_usage_dedicated int,
    mem_usage_dynamic int,
    vddc float
);

COMMENT ON TABLE gpuz.sensor IS 'Frequencies (f_*) are [MHz], Temperature [degC], Mem. usage in [MiB], VDDC in [V]. The rest are [%].';
CREATE OR REPLACE FUNCTION gpuz.import_sensor (p_path varchar(260))
RETURNS void
AS
$DEF$
BEGIN

	CREATE TEMPORARY TABLE pg_temp._import (LIKE gpuz.sensor);

	EXECUTE format(
        $$COPY pg_temp._import FROM '%s' DELIMITER AS ',' NULL AS '-' CSV;$$,
        p_path
    );

	INSERT INTO gpuz.sensor
    SELECT *
      FROM pg_temp._import
    ON CONFLICT DO NOTHING;

    DROP TABLE pg_temp._import;

END
$DEF$
language plpgsql;

-- SELECT gpuz.import_sensor('L:\data\gpuz\sensor.log.csv');



-- In-situ data post-processing
-- ----------------------------
CREATE MATERIALIZED VIEW public.gpuz_data AS 
  WITH differenced AS (
          SELECT *
               , (t - (lag(t, 1) OVER (ORDER BY t ASC))) AS t_delta
            FROM gpuz.sensor
       )
SELECT *
     , sum(CASE WHEN extract('epoch' FROM t_delta) < 30 THEN 0 ELSE 1 END) OVER (ORDER BY t) AS session_id
  FROM differenced
;
